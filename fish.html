<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>F.I.S.H</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<style>
* { margin:0; padding:0; box-sizing:border-box; }

body {
  font-family: 'Montserrat', sans-serif;
  background: #fff;
  color: #111;
  overflow-x: hidden;
}

.header {
  padding: 80px 20px 40px;
  text-align: center;
}

.header img {
  max-width: 150px;
}

.viewer-section {
  width: 100%;
  height: 520px;
}

#three-container {
  width: 100%;
  height: 100%;
  cursor: grab;
}

#three-container:active {
  cursor: grabbing;
}

.description {
  max-width: 900px;
  margin: 80px auto;
  padding: 0 20px;
  font-size: 18px;
  line-height: 1.7;
}

.mockups {
  max-width: 1100px;
  margin: 60px auto;
  padding: 0 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 30px;
}

.mockups img {
  width: 100%;
  border-radius: 12px;
}

.deck-full {
  margin-top: 100px;
}

.deck-full img {
  width: 100%;
  display: block;
}
</style>
</head>

<body>

<div class="header">
  <img src="fish-logo.png" alt="F.I.S.H logo">
</div>

<section class="viewer-section">
  <div id="three-container"></div>
</section>

<section class="description">
  <p>In collaboration with an initiative started by former athlete and swimmer Karl Palmqvist—who swam around Gotland, one of Sweden’s largest islands, to raise awareness about the ecocide of the Baltic Sea as well as mental health—this deck of cards was created. Its goal was to raise additional funds for the charity fundraisers initiated by Karl in partnership with Naturskyddsföreningen (The Swedish Society for Nature Conservation) and Suicide Zero.</p>

   <p>Finns I Sjön & Hav or F.I.S.H (derived from the Swedish name for ’Go Fish’) is a deck of cards.</p>
</section>

<section class="mockups">
  <img src="mockup1.jpg">
  <img src="mockup2.jpg">
  <img src="mockup3.jpg">
</section>

<section class="deck-full">
  <img src="deck-full.jpg">
</section>

<script>
const container = document.getElementById("three-container");

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const camera = new THREE.PerspectiveCamera(
  45,
  container.clientWidth / container.clientHeight,
  0.1,
  100
);
camera.position.z = 6;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

/* LIGHTING */
scene.add(new THREE.AmbientLight(0xffffff, 0.9));
const light = new THREE.DirectionalLight(0xffffff, 0.7);
light.position.set(5, 5, 5);
scene.add(light);

/* TEXTURES */
const loader = new THREE.TextureLoader();

const sideTexture = loader.load("card-side.jpg");
const frontTexture = loader.load("card-front.jpg");
const backTexture  = loader.load("card-back.jpg");

/* ROTATED SIDE TEXTURE (FOR TOP/BOTTOM) */
const sideRotated = sideTexture.clone();
sideRotated.center.set(0.5, 0.5);
sideRotated.rotation = Math.PI / 2;
sideRotated.needsUpdate = true;

/* MATERIALS
   Box sides order:
   0 = right
   1 = left
   2 = top
   3 = bottom
   4 = front
   5 = back
*/

// Right side - flipped 180°
const rightMat = new THREE.MeshStandardMaterial({ map: sideTexture });
rightMat.map.center.set(0.5, 0.5);
rightMat.map.rotation = Math.PI / 2;
rightMat.map.needsUpdate = true;

// Left side - flipped 180°
const leftMat = new THREE.MeshStandardMaterial({ map: sideTexture });
leftMat.map.center.set(0.5, 0.5);
leftMat.map.rotation = Math.PI / 2;
leftMat.map.needsUpdate = true;

// Top - rotated 90°
const topMat = new THREE.MeshStandardMaterial({ map: sideTexture });
topMat.map.center.set(0.5, 0.5);
topMat.map.rotation = Math.PI / 2;
topMat.map.needsUpdate = true;

// Bottom - rotated 90°
const bottomMat = new THREE.MeshStandardMaterial({ map: sideTexture });
bottomMat.map.center.set(0.5, 0.5);
bottomMat.map.rotation = Math.PI / 2;
bottomMat.map.needsUpdate = true;

// Front / Back
const frontMat = new THREE.MeshStandardMaterial({ map: frontTexture });
const backMat  = new THREE.MeshStandardMaterial({ map: backTexture });

const materials = [ rightMat, leftMat, topMat, bottomMat, frontMat, backMat ];





/* CARD BOX */
const geometry = new THREE.BoxGeometry(2.4, 3.4, 0.6);
const cardBox = new THREE.Mesh(geometry, materials);
scene.add(cardBox);

/* MOUSE DRAG ROTATION */
let dragging = false;
let prevX = 0, prevY = 0;
let velX = 0, velY = 0;

container.addEventListener("mousedown", e => {
  dragging = true;
  prevX = e.clientX;
  prevY = e.clientY;
});

window.addEventListener("mouseup", () => dragging = false);

container.addEventListener("mousemove", e => {
  if (!dragging) return;
  const dx = e.clientX - prevX;
  const dy = e.clientY - prevY;
  cardBox.rotation.y += dx * 0.005;
  cardBox.rotation.x += dy * 0.005;
  velX = dx * 0.0015;
  velY = dy * 0.0015;
  prevX = e.clientX;
  prevY = e.clientY;
});

/* RESIZE */
window.addEventListener("resize", () => {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

/* ANIMATE */
function animate() {
  requestAnimationFrame(animate);
  if (!dragging) {
    cardBox.rotation.y += 0.002 + velX;
    cardBox.rotation.x += velY;
    velX *= 0.95;
    velY *= 0.95;
  }
  renderer.render(scene, camera);
}
animate();
</script>

</body>
</html>

