<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>F.I.S.H</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<style>
* { margin:0; padding:0; box-sizing:border-box; }

body {
  font-family: 'Montserrat', sans-serif;
  background: #fff;
  color: #111;
  overflow-x: hidden;
}

.header {
  padding: 80px 20px 40px;
  text-align: center;
}

.header img {
  max-width: 150px;
}

.viewer-section {
  width: 100%;
  height: 520px;
}

#three-container {
  width: 100%;
  height: 100%;
  cursor: grab;
}

#three-container:active {
  cursor: grabbing;
}

.description {
  max-width: 720px;             /* narrower = more editorial */
  margin: 80px auto 90px;       /* top & bottom spacing */
  padding: 0 20px;
  font-family: 'Montserrat', sans-serif;
  font-size: 17px;              /* slightly smaller for professional look */
  line-height: 1.75;            /* good readability */
  color: #222;                  /* soft dark, not pure black */
}

.description p {
  margin-bottom: 22px;          /* space between paragraphs */
}

.description p:last-child {
  margin-bottom: 0;             /* remove extra margin at end */
}

.description .intro {
  font-size: 19px;              /* slightly larger for intro emphasis */
  line-height: 1.8;
  font-weight: 500;
  margin-bottom: 32px;
}

.description strong {
  font-weight: 600;             /* emphasize bold text */
}

.description em {
  font-style: italic;           /* emphasize italics */
}



/* MOCKUPS GRID */
.mockups {
  max-width: 1100px;
  margin: 60px auto;
  padding: 0 20px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: auto auto;
  gap: 20px;
}

.mockups img {
  width: 100%;
  border-radius: 12px;
}

.mockups img:nth-child(1) {
  grid-column: 1;
  grid-row: 1;
}

.mockups img:nth-child(2) {
  grid-column: 1;
  grid-row: 2;
}

.mockups img:nth-child(3) {
  grid-column: 2;
  grid-row: 1 / span 2; /* spans both rows on right */
}

.deck-full {
  margin-top: 100px;
}

.deck-full img {
  width: 100%;
  display: block;
}
</style>
</head>

<body>

<div class="header">
  <img src="fish-logo.png" alt="F.I.S.H logo">
</div>

<section class="viewer-section">
  <div id="three-container"></div>
</section>

<section class="description">
  <p class="intro">
    I created this deck of cards in collaboration with an initiative started by former athlete and swimmer Karl Palmqvist.
  </p>

  <p>
    Karl swam around Gotland, Sweden’s largest island, to raise awareness about the ecocide of the Baltic Sea and mental health. The deck’s goal was to raise additional funds for the charity initiated by Karl called <em>Gotland Runt</em> in partnership with Naturskyddsföreningen (The Swedish Society for Nature Conservation) and Suicide Zero.
  </p>

  <p>
    <em>Finns I Sjön och Hav</em>, or <em>F.I.S.H</em> (derived from the Swedish name for the card game “Go Fish”), is a deck of cards with very silly illustrations.
  </p>

  <p>
   The reason why is because neuroscience has proven that people remember things better if it also made them release dopamine. The point of the cards looking goofy is to (hopefully) make someone atleast chuckle.
  </p>
</section>


<section class="mockups">
  <img src="mockup1.jpg" alt="">
  <img src="mockup2.jpg" alt="">
  <img src="mockup3.jpg" alt="">
</section>

<section class="deck-full">
  <img src="deck-full.jpg" alt="Full card deck">
</section>

<script>
const container = document.getElementById("three-container");

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const camera = new THREE.PerspectiveCamera(
  45,
  container.clientWidth / container.clientHeight,
  0.1,
  100
);
camera.position.z = 6;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

/* LIGHTING */
scene.add(new THREE.AmbientLight(0xffffff, 0.9));
const light = new THREE.DirectionalLight(0xffffff, 0.7);
light.position.set(5,5,5);
scene.add(light);

/* TEXTURES */
const loader = new THREE.TextureLoader();
const sideTexture  = loader.load("card-side.jpg");
const frontTexture = loader.load("card-front.jpg");
const backTexture  = loader.load("card-back.jpg");

/* ROTATED SIDE TEXTURE (FOR TOP/BOTTOM) */
const sideRotated = sideTexture.clone();
sideRotated.center.set(0.5, 0.5);
sideRotated.rotation = Math.PI / 2;
sideRotated.needsUpdate = true;

// Left side flipped 180°
const sideLeftFlipped = sideTexture.clone();
sideLeftFlipped.center.set(0.5,0.5);
sideLeftFlipped.rotation = Math.PI;
sideLeftFlipped.needsUpdate = true;

// Bottom flipped 180° + 90°
const sideBottomFlipped = sideTexture.clone();
sideBottomFlipped.center.set(0.5,0.5);
sideBottomFlipped.rotation = Math.PI / 2 + Math.PI;
sideBottomFlipped.needsUpdate = true;

/* MATERIALS (0:right,1:left,2:top,3:bottom,4:front,5:back) */
const materials = [
  new THREE.MeshStandardMaterial({ map: sideTexture }),      // right
  new THREE.MeshStandardMaterial({ map: sideLeftFlipped }),  // left ✅ flipped 180
  new THREE.MeshStandardMaterial({ map: sideRotated }),      // top
  new THREE.MeshStandardMaterial({ map: sideBottomFlipped }),// bottom ✅ flipped 180 + 90
  new THREE.MeshStandardMaterial({ map: frontTexture }),     // front
  new THREE.MeshStandardMaterial({ map: backTexture })       // back
];

/* CARD BOX */
const geometry = new THREE.BoxGeometry(2.4,3.4,0.6);
const cardBox = new THREE.Mesh(geometry, materials);
scene.add(cardBox);

/* MOUSE DRAG ROTATION */
let dragging = false;
let prevX = 0, prevY = 0;
let velX = 0, velY = 0;

container.addEventListener("mousedown", e => {
  dragging = true;
  prevX = e.clientX;
  prevY = e.clientY;
});

window.addEventListener("mouseup", () => dragging = false);

container.addEventListener("mousemove", e => {
  if (!dragging) return;
  const dx = e.clientX - prevX;
  const dy = e.clientY - prevY;
  cardBox.rotation.y += dx * 0.005;
  cardBox.rotation.x += dy * 0.005;
  velX = dx * 0.0015;
  velY = dy * 0.0015;
  prevX = e.clientX;
  prevY = e.clientY;
});

/* RESIZE */
window.addEventListener("resize", () => {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

/* ANIMATE */
function animate() {
  requestAnimationFrame(animate);
  if (!dragging) {
    cardBox.rotation.y += 0.002 + velX;
    cardBox.rotation.x += velY;
    velX *= 0.95;
    velY *= 0.95;
  }
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>

